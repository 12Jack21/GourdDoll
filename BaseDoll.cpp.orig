#include "BaseDoll.h"
#include "GameManager.h"
#include "BaseLevel.h"
#include "UpdateMenu.h"
#include "TouchLayer.h"
#include "Gourd.h"


BaseDoll::BaseDoll() :isUpdateMenuShown(false) 
{

};

BaseDoll::~BaseDoll() {};


bool BaseDoll::init() {
	if (!Sprite::init()) {
		return false;
	}
	isUpdateMenuShown = false;
	return true;
}

void BaseDoll::sellDoll() {
	static_cast<Gourd *>(this->getParent())->gourd->setVisible(true);
	removeDoll();
}

void BaseDoll::removeDoll() {
<<<<<<< HEAD
	static_cast<BaseLevel *>(this->getParent()->getParent())->playerState->removeDollInfo();
=======
	static_cast<BaseLevel *>(this->getParent()->getParent())->playState->removeDollInfo();
>>>>>>> 87faf720e8e8b26bfcbd0ad24cd4eda8e50abde5
	static_cast<Gourd *>(this->getParent())->Effect();
	this->unscheduleAllCallbacks();
	this->removeAllChildren();
	this->removeFromParent();
}

void BaseDoll::setListener() {
	auto listener = EventListenerTouchOneByOne::create();
	listener->onTouchBegan = CC_CALLBACK_2(BaseDoll::onTouchBegan, this);
	listener->onTouchEnded = CC_CALLBACK_2(BaseDoll::onTouchEnded, this);
	_eventDispatcher->addEventListenerWithSceneGraphPriority(listener, gourd);
}

void BaseDoll::checkNearestMonster() {
	auto instance = GameManager::getInstance();
	auto monsterVector = instance->monsterVector;

	auto curMinDistance = this->scope;

	BaseMonster * monsterTemp = NULL;
	//for循环找到在DOLL内最近的MONSTER
	for (int i = 0; i < monsterVector.size(); i++) {
		auto monster = monsterVector.at(i);
		double distance = this->getParent()->getPosition().getDistance(monster->monsterSprite->getPosition());
<<<<<<< HEAD
			if (distance < curMinDistance && monster->getAttackByTower()) {
=======
			if (distance < curMinDistance && monster->getAttackByDoll()) {
>>>>>>> 87faf720e8e8b26bfcbd0ad24cd4eda8e50abde5
				distance = curMinDistance;
				monsterTemp = monster;
		}
	}
	nearestMonster = monsterTemp;
}

void BaseDoll::hideUpdateMenu() {
	static_cast<BaseLevel *>(this->getParent())->mTouchLayer->removeChildByTag(getTag() + 100);
	isUpdateMenuShown = false;
}

void BaseDoll::onTouchEnded(Touch * t, Event *e) {
	auto target = static_cast<Sprite *>(e->getCurrentTarget());
	Point locationInNode = target->convertTouchToNodeSpace(t);

	Size size = target->getContentSize();
	Rect rect = Rect(0, 0, size.width, size.height);
	if (rect.containsPoint(locationInNode)) {
		//获取单击区域，显示菜单
<<<<<<< HEAD
		static_cast<BaseLevel *>(this->getParent())->playerState->showDollInfo(getDollType());
=======
		static_cast<BaseLevel *>(this->getParent())->playState->showDollInfo(getDollType());
>>>>>>> 87faf720e8e8b26bfcbd0ad24cd4eda8e50abde5
		if (isUpdateMenuShown) {
			hideUpdateMenu();
		}
		else
		{
			showUpdateMenu();
		}
	}
	else
	{
		hideUpdateMenu();
	}

}
//初始化塔的等级
void BaseDoll::initDoll(int level) {
	if (level == 1) {
		dollBase = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter->setPosition(Point(dollBase->getContentSize().width / 2 + 3, dollBase->getContentSize().height / 2 + 34));
	}
	if (level == 2) {
		dollBase = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter->setPosition(Point(dollBase->getContentSize().width / 2 + 3, dollBase->getContentSize().height / 2 + 34));
	}
	if (level = 3) {
		dollBase = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter = Sprite::createWithSpriteFrameName(String::createWithFormat(".png", level)->getCString());
		shooter->setPosition(Point(dollBase->getContentSize().width / 2 + 3, dollBase->getContentSize().height / 2 + 34));
	}
	dollBase->setPosition(Point(0, -10));
	dollBase->addChild(shooter);
	curBullet = NULL;
}

<<<<<<< HEAD
=======

>>>>>>> 87faf720e8e8b26bfcbd0ad24cd4eda8e50abde5
void BaseDoll::addGourd() {
	gourd = Sprite::createWithSpriteFrameName(".png");
	gourd->setAnchorPoint(Point(/*有问题*/));
	addChild(gourd);
}

<<<<<<< HEAD
void BaseDoll::shoot(float dt) {
	auto instance = GameManager::getInstance();
	checkNearestMonster();
	if (nearestMonster != NULL && nearestMonster->getCurHp() > 0) {
		Point shootVector = nearestMonster->monsterSprite->getPosition() - this->getParent()->getPosition();

		auto position = curBullet->getPosition() - shootVector;
		auto rotation = atan2(position.y, position.x);
		float angle = CC_RADIANS_TO_DEGREES(rotation);
		curBullet->setRotation(180.0f - angle);

		dollBase->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(String::createWithFormat(" ", level)->getCString())));

		if (shootVector.y)
		{
			shooter->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(" ")));
		}
		else
		{
			shooter->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(" ")));
		}

		auto move = MoveTo::create(0.25f, shootVector);
		auto action = Spawn::create(move, NULL);

		curBullet->setBulletAction(action);
		curBullet->shoot();
		curBullet = NULL;
	}

}
=======
//void BaseDoll::shoot(float dt) {
//	auto instance = GameManager::getInstance();
//	checkNearestMonster();
//	if (nearestMonster != NULL && nearestMonster->getCurHp() > 0) {
//		
//	}
//	Point shootVector = nearestMonster->monsterSprite->getPosition() - this->getParent()->getPosition();
//
//	auto position = curBullet->getPosition() - shootVector;
//	auto rotation = atan2(position.y, position.x);
//	float angle = CC_RADIANS_TO_DEGREES(rotation);
//	curBullet->setRotation(180.0f - angle);
//
//	dollBase->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(String::createWithFormat(" ", level)->getCString())));
//
//	if (shootVector.y)
//	{
//		shooter->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(" ")));
//	}
//	else
//	{
//		shooter->runAction(Animate::create(AnimationCache::getInstance()->getAnimation(" ")));
//	}
//
//	auto move = MoveTo::create(0.25f, shootVector);
//	auto action = Spawn::create(move, NULL);
//
//	curBullet->setBulletAction(action);
//	curBullet->shoot();
//	curBullet = NULL;
//}
>>>>>>> 87faf720e8e8b26bfcbd0ad24cd4eda8e50abde5
void BaseDoll::showDollInfo() {

}